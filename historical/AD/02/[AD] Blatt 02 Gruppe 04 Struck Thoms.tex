% Commands

\newcommand{\authorinfo}{Arne Struck, Lars Thoms}
\newcommand{\titleinfo}{AD [HA] zum 6. 11. 2013}
\newcommand{\qed}{\ \square}
\newcommand{\todo}{\textcolor{red}{\textbf{TODO}}}

% ------------------------------------------------------

% Packages & Stuff

\documentclass[a4paper,11pt,fleqn]{scrartcl}
\usepackage[german,ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[top=1.3in, bottom=1.2in, left=0.9in, right=0.9in]{geometry}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{pgfplots}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage[parfill]{parskip}
\usetikzlibrary{calc}
\usetikzlibrary{patterns}


% ------------------------------------------------------

% Title & Pages

\title{\titleinfo}
\author{\authorinfo}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\authorinfo}
\fancyhead[R]{\titleinfo}
\fancyfoot[C]{\thepage}

\begin{document}
	\maketitle
	\begin{enumerate}
		\item[\textbf{1.}]
		\begin{enumerate}
			\item[a)]\quad \\
				Es liegen \(k^l\) Blätter maximal in der l. Ebene. Von jedem Knoten gehen k Knoten ab, das führt zum 
				folgenden: 0. Ebene (root): \(1 = k^0\), 1. Ebene: \(k = k^1\), 2. Ebene: \(k\cdot k = k^2\),\\
				3. Ebene: \(k\cdot k \cdot k = k^3\) ... l.Ebene: \(k^l\)
			\item[b)]\quad \\
				Der volle Baum hat \(\sum\limits_{i=0}^l k^i = \frac{k^{i+1}-1}{k-1}=\frac{k^i+k^i\cdot(k-1)}{k-1}=
				\frac{k^i-1}{k-1}+k^i\) Knoten, die Summe der Knoten aller Ebenen (eine volle Ebene bemisst sich, wie in a)
				dargestellt auf \(k^l\)).
			\item[c)]\quad \\
				Der vollständige Baum hat \(\sum\limits_{i=0}^{l-1}k^i +c = \frac{k^i-1}{k-1}+k^i-k^l+c\ |c\in\mathbb{N}:1\leq c\leq k^l\)				
				Blätter. Der vollständige Baum ist bis zu seiner vorletzten Ebene maximal gefüllt, deswegen die 
				Summe bis $l-1$, c repräsentiert die Anzahl der Blätter in der letzten Ebene, welche zwischen 
				einem (sonst wäre der Baum voll und hätte l-1 Ebenen) und $k^l$ (ein voller Baum ist 
				vollständig) Blättern.
			\item[d)]\quad \\
				Der Baum hat n-1 Kanten, da jeder Knoten (bis auf den Wurzelknoten) eine Kante besitzt durch 
				die er mit seinem Elternknoten verbunden ist.
		\end{enumerate}
		
		\item[\textbf{2.}]
		\begin{enumerate}
			\item[a)]\quad \\
				Die Laufzeit kann wie folgt (für OrderX) hergeleitet werden, die Reihenfolge der prints ist nicht relevant. 
				\(
				\begin{array}{lll}
					print(v) &\quad & \Theta(1) \\
					OrderX(l) &\quad & \mathcal{O}(\frac{k-1}{2}) \\
					OrderX(r) &\quad & \mathcal{O}(\frac{k-1}{2})
				\end{array}
				\) \\
				Das master-Theorem ist nun anwendbar, \\ \\
				\(T(k)=2T(\big\lceil\frac{ k-1}{2}\big\rceil)+\mathcal{O}(k^0)\) \\
				Da \(\log_2 2 = 1\) gilt, folgt \(\mathcal{O}(k^1)\) 
				
			\item[b)]\quad \\
				Die  Laufzeiten sind bei gleicher Knotenzahl identische (wie in a) zu sehen, alle Algorithmen haben die
				gleiche Anzahl an Aufrufen, da nirgends abgebrochen wird, außer wenn keine Kindknoten verfügbar sind).
				
			\newpage
			\item[c)]\quad \\
				\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
                	    			level 1/.style={sibling distance=50mm},
			        	            level 2/.style={sibling distance=25mm},
            				        level 3/.style={sibling distance=12.5mm},
                				    level 4/.style={sibling distance=6.25mm}]
                				    \node{N}
                				    	child{node{A}
	                							child{node{O}
	                								child{node{E}
	                									child{node{I}}
	                								}
	                								child{node{F}}
	                							}
	                							child{node{M}
	                								child{node{R}}
	                								child{node{L}}
	                							}
	                					}
	                					child{node{U}
	                						child{node{S}
	                							child{node{G}}
	                							child{node{A}}
	                						}
	                						child{node{R}
	                							child{node{T}}
	                							child{node{H}}
	                						}
	                					};
					
				\end{tikzpicture} \\ \\
				Order1: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline N&A&O&E&I&F&M&R&L&U&S&G&A&R&T&H \\ \hline
						\end{tabular} \\
				Order2: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline I&E&O&F&A&R&M&L&N&G&S&A&U&T&R&H \\ \hline
						\end{tabular}  \\
				Order3: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline I&E&F&O&R&L&M&A&G&A&S&T&H&R&U&N \\ \hline
						\end{tabular}  \\
			\item[d)]\quad \\
				Der LOVELYTREE nach Order 2: \\ \\
				\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
                	    			level 1/.style={sibling distance=50mm},
			        	            level 2/.style={sibling distance=25mm},
            				        level 3/.style={sibling distance=12.5mm},
                				    level 4/.style={sibling distance=6.25mm}]
                				    \node{T}
                				    	child{node{E}
                				    		child{node{O}
                				    			child{node{L}}
                				    			child{node{V}}
                				    		}
                				    		child{node{Y}
												child{node{L}}
                				    		}
                				    	}
                				    	child{node{E}
											child{node{R}}
											child{node{E}}                				    	
                				    	}
                				    ;					
				\end{tikzpicture} \\ \\
				Nach Level-Order: Order3: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline T&E&E&O&Y&R&E&L&V&L\\ \hline
						\end{tabular}  \\ \\
				\newpage
			\item[e)]\quad \\
				Ternärer Baum mit vorgegebener Befehlsreihenfolge: \\ \\
				\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
                	    			level 1/.style={sibling distance=40mm},
			        	            level 2/.style={sibling distance=12.5mm},
            				        level 3/.style={sibling distance=10mm}]
                				    \node{N}
                				    	child{node{A}
                				    		child{node{M}
												child{node{T}}                				    			
												child{node{H}}
												child{node{I}}
                				    		}  
                				    		child{node{S}}
                				    		child{node{R}}
                				    	}
                				    	child{node{U}
        	        				    	child{node{E}}
    	            				    	child{node{F}}
	                				    	child{node{R}}
                				    	}
                				    	child{node{o}
        	        				    	child{node{L}}
    	            				    	child{node{G}}
	                				    	child{node{A}}
                				    	}
                				    ;					
				\end{tikzpicture} \\ \\
				Ausgabe: Order3: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline A&L&G&O&R&I&T&H&M&S&A&R&E&F&U&N \\ \hline
						\end{tabular}  \\
		\end{enumerate}
		\item[\textbf{3.}]
		\begin{enumerate}
			\item[a)]\quad \\
				\(
				\begin{array}{rcl}
				\Big(x\cdot \frac{\ln(n)}{\ln(x)}\Big)' &=& 
					\frac{\ln(n)}{\ln(x)}+\Big(\frac{\ln(n)}{\ln(x)}\Big)' \\
					&=& \frac{\ln(n)}{\ln(x)} - \frac{\ln(n)\ln(x)'}{(\ln(x))^2} \\
					&=& \frac{\ln(n)}{\ln(x)} - \frac{\ln(n)\ln(x)'}{(\ln(x))^2} \\
					&=& \frac{\ln(n)}{\ln(x)} - \frac{\ln(n)}{x(\ln(x))^2} \\
					&=& \frac{\ln(n)\ln(x)}{\ln(x)^2} - \frac{\ln(n)}{x(\ln(x))^2} \\
					&=& \frac{\ln(n)(\ln(x)-1)}{\ln(x)^2} \\
				\end{array} 
				\) \\
				Man sieht, dass einer der Faktoren im Zähler 0 sein muss, damit \(\frac{\ln(n)
				(\ln(x)-1)}{\ln(x)^2} = 0\)	gilt. Da n beliebig, aber fest ist, ist die Frage,
				für welches x dies gilt. Wenn $x = e$ gilt, dann 	folgt \(\frac{\ln(n)
				(\ln(e)-1)}{\ln(e)^2} = \frac{0}{1}\) \\
				Da es sich um die einzige Extremstelle handelt, ist es das gesuchte Minimum.
			\item[b)]\quad \\
				Wir wissen aus b), dass das ideale $x = k = e$ gilt, da $k\in\mathbb{N}$ gilt und $e$ näher an 3, als an 2 ist,
				ist $k=3$ die optimale Belegung für jedes $n$ \\ \\
				\(
				\begin{array}{rcl}
					\lceil 3 \cdot\log_3(10^1)\rceil &=& 7 \\
					\lceil 3 \cdot\log_3(10^2)\rceil &=& 13 \\
					\lceil 3 \cdot\log_3(10^3)\rceil &=& 19 \\
					\lceil 3 \cdot\log_3(10^4)\rceil &=& 26 \\
					\lceil 3 \cdot\log_3(10^5)\rceil &=& 32 \\
					\lceil 3 \cdot\log_3(10^6)\rceil &=& 38 \\
					\lceil 3 \cdot\log_3(10^7)\rceil &=& 45 \\
					\lceil 3 \cdot\log_3(10^8)\rceil &=& 51 \\
					\lceil 3 \cdot\log_3(10^9)\rceil &=& 57 \\
				\end{array}
				\) \quad \quad
				\(
				\begin{array}{rcl}
					\lceil 2 \cdot\log_2(10^1)\rceil &=& 7 \\
					\lceil 2 \cdot\log_2(10^2)\rceil &=& 14 \\
					\lceil 2 \cdot\log_2(10^3)\rceil &=& 20 \\
					\lceil 2 \cdot\log_2(10^4)\rceil &=& 27 \\
					\lceil 2 \cdot\log_2(10^5)\rceil &=& 34 \\
					\lceil 2 \cdot\log_2(10^6)\rceil &=& 40 \\
					\lceil 2 \cdot\log_2(10^7)\rceil &=& 47 \\
					\lceil 2 \cdot\log_2(10^8)\rceil &=& 54 \\
					\lceil 2 \cdot\log_2(10^9)\rceil &=& 60 \\
				\end{array}
				\)
			\item[c)]\quad \\
				k = 2 wird verwendet, weil die momentane Rechnerstrukturen, Binärstrukturen
				einfacher verarbeiten können.
			\newpage
			\item[d)]\quad \\
				Da der Wurzelknoten des jeweiligen Max-Heaps das größte Kind darstellt, ist der 
				Aufwand für einmal vertauschen 1. Allerdings wird durch das Vertauschen im Max-
				Heap die Max-Heap-Eigenschaft gestört und muss wieder hergestellt werden. 
				Dies dauert im worst-case $\frac{k}{2}$ Schritte. Es treten allerdings nicht 
				nur Veränderungen im Max-Heap des Elternknotens auf, sondern auch in dem des 
				(ehemaligen) Kindknotens und dem des Elternknotens des Elternknotens. Auch 
				diese müssten wieder Heapified werden. Da für einen Binär-Heap mit k Elementen
				$2\lceil\log_2(k)\rceil\cdot 2$ und es 3 zu verändernde Max-Heaps existieren
				gilt folgt: $k \cdot 3 \cdot (\lceil\log_2(k)\rceil + 2) + 1$ für die 
				notwendige Schrittzahl.
				
			\item[e)]\quad \\
				Es sind 2 Vertauschungen vom Originalbaum weg notwendig: \\ \\
				\begin{tabular}{ccccc}
					\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
					                    level 1/.style={sibling distance=22.5mm},
                					    level 2/.style={sibling distance=12.5mm},
					 	                level 3/.style={sibling distance=6.25mm}
                				    	]
        	        	\node{1}
                    		child{node{8}
                      			child{node{7}}
                      			child{node{3}}
                    		}
                    		child{node{6}
                      			child{node{5}}
                      			child{node{2}}
                    		};
                	\end{tikzpicture} & \quad \quad &
					\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
					                    level 1/.style={sibling distance=22.5mm},
                					    level 2/.style={sibling distance=12.5mm},
					 	                level 3/.style={sibling distance=6.25mm}
                				    	]
               		    \node{8}
                    		child{node{1}
                      			child{node{7}}
                      			child{node{3}}
                    		}
                    		child{node{6}
                      			child{node{5}}
                      			child{node{2}}
                    		};
                	\end{tikzpicture} & \quad \quad &
                	\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
					                    level 1/.style={sibling distance=22.5mm},
                					    level 2/.style={sibling distance=12.5mm},
					 	                level 3/.style={sibling distance=6.25mm}
                				    	]
                  		\node{8}
                    		child{node{7}
                      			child{node{1}}
                      			child{node{3}}
                    		}
                    		child{node{6}
                     			child{node{5}}
                      			child{node{2}}
                    		};
                	\end{tikzpicture}
				\end{tabular} \\ \\ \\
				Es ist eine Vertauschung vom Originalbaum notwendig: \\ \\
				\begin{tabular}{ccc}
					\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
					                    level 1/.style={sibling distance=22.5mm},
                					    level 2/.style={sibling distance=12.5mm},
					 	                level 3/.style={sibling distance=6.25mm}
                				    	]
						\node{8}
                    		child{node{1}
                      			child{node{7}}
                      			child{node{3}}
 		                   	}
                    		child{node{6}
                      			child{node{5}}
			                    child{node{2}}
                    		};
					\end{tikzpicture} & \quad \quad &
					\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
					                    level 1/.style={sibling distance=22.5mm},
                					    level 2/.style={sibling distance=12.5mm},
					 	                level 3/.style={sibling distance=6.25mm}
                				    	]
						\node{8}
                    		child{node{7}
                      			child{node{1}}
 			                    child{node{3}}
                    		}
                    		child{node{6}
                      			child{node{5}}
                      			child{node{2}}
		                    };
					\end{tikzpicture}
				\end{tabular}
				
			\item[f)]\quad \\
				Wir wissen, dass ein k-närer Baum $\lceil k\log_k(n)\rceil$ Schritte benötigt, 
				daraus folgt folgender Beweis:
				\begin{enumerate}
					\item[Beh.:]\quad \\
						\(\forall n\in\mathbb{N}\) gilt: \(\lceil 3\log_3(n)\rceil\leq 
						\lceil 2\log_2(n)\rceil\)
					\item[I.Anf.:]\quad \\
						\(\lceil 3\log_3(1)\rceil = 0 = \lceil 2\log_2(1)\rceil\)
					\item[I.A.:]\quad \\
						Die Behauptung gilt für ein bestimmtes, aber frei wählbares 
						\(n\in\mathbb{N}\)
					\newpage
					\item[I.S.:] \((z.z.: \lceil 3\log_3(n+1)\rceil\leq\lceil 2\log_2(n+1)
						\rceil)\) \\ \\
						\(
						\begin{array}{rclccl}
							\lceil3\log_3(n+1)\rceil &=& \big\lceil 3\frac{\ln(n+1)}{\ln(3)} 
							\big\rceil \\
							&=&\big\lceil \ln(n+1)\frac{3}{\ln(3)} \big\rceil
							&\leq &&
							\big\lceil \ln(n+1)\frac{2}{\ln(2)} \big\rceil \\	
							&&&&=& \big\lceil 2\frac{\ln(n+1)}{\ln(2)} \big\rceil \\
							&&&&=& \lceil 2\log_2(n+1) \rceil
						\end{array}
						\) \\
						Damit ist die Behauptung bewiesen $\qed$
				\end{enumerate}
		\end{enumerate}
		
		\item[\textbf{4.}]
		\begin{enumerate}
			\item[a)]\quad \\
				merge(22579,1248) \\
				1 $\circ$ merge(22579,248) \\
				12 $\circ$ merge(2579,248) \\
				122 $\circ$ merge(579,248) \\
				1222 $\circ$ merge(579,48) \\
				12224 $\circ$ merge(579,8) \\
				122245 $\circ$ merge(79,8) \\
				1222457 $\circ$ merge(9,8) \\
				12224578 $\circ$ merge(9,[]) \\
				122245789 \\
			\item[b)]\quad \\
				Input(splitted): 6 7 8 3 4 2 9 1 \\ \\
				\begin{tikzpicture}[
                            position label/.style={
                                        below = 3pt,
                                        text height = 1.5ex,
                                        text depth = 1ex
                                },
                                brace/.style={
                                        decoration={brace, mirror},
                                        decorate
                                }]

                        \node [position label] (alvl1) at (0,0) {$6$};
                        \node [position label] (alvl2) at (0.5,0) {$7$};
                        \node [position label] (alvl3) at (1,0) {$8$};
                        \node [position label] (alvl4) at (1.5,0) {$3$};
                        \node [position label] (alvl5) at (2,0) {$4$};
                        \node [position label] (alvl6) at (2.5,0) {$2$};
                        \node [position label] (alvl7) at (3,0) {$9$};
                        \node [position label] (alvl8) at (3.5,0) {$1$};

                        \draw [brace] (alvl1.south) -- (alvl2.south);
                        \draw [brace] (alvl3.south) -- (alvl4.south);
                        \draw [brace] (alvl5.south) -- (alvl6.south);
                        \draw [brace] (alvl7.south) -- (alvl8.south);

                        \node [position label] (blvl1) at (0.25,-0.7) {$67$};
                        \node [position label] (blvl2) at (1.25,-0.7) {$38$};
                        \node [position label] (blvl3) at (2.25,-0.7) {$24$};
                        \node [position label] (blvl4) at (3.25,-0.7) {$19$};

                        \draw [brace,decoration={raise=4ex}] (alvl1.south) -- (alvl4.south);
                        \draw [brace,decoration={raise=4ex}] (alvl5.south) -- (alvl8.south);

                        \node [position label] (clvl1) at (0.75,-1.4) {$3678$};
                        \node [position label] (clvl2) at (2.75,-1.4) {$1249$};

                        \draw [brace,decoration={raise=8ex}] (alvl1.south) -- (alvl8.south);

                        \node [position label] (dlvl1) at (1.75,-2.1) {$12346789$};
                \end{tikzpicture}
				
			\item[c)]\quad \\
				Die erste Möglichkeit ist in merge $x[1] \leq y[1]$ zu $x[1] \geq y[1]$ 
				abzuändern, wie folgt dargestellt: 
					\begin{algorithmic} \\
						\Function{merge}{$x[1..k],y[1..l]$}
							\If {$k = 0$} \State \Return $y[1..l]$
							\EndIf
							\If {$l = 0$} \State \Return $x[1..k]$
							\EndIf
							\If {$x[1]\geq y[1]$} \State 
								\Return{$x[1]\ \circ$ \Call{merge}{$x[2..k],y[1..l]$}}
							\Else \State 
								\Return{$y[1]\ \circ$ \Call{merge}{$x[1..k],y[2..l]$}}
							\EndIf
						\EndFunction
					\end{algorithmic}
				\newpage
				Oder man stellt die Ausführung der Konkatenation in merge um, wie im Folgenden:
				\begin{algorithmic} \\
						\Function{merge}{$x[1..k],y[1..l]$}
							\If {$k = 0$} \State \Return $y[1..l]$
							\EndIf
							\If {$l = 0$} \State \Return $x[1..k]$
							\EndIf
							\If {$x[1]\leq y[1]$} \State 
								\Return{\Call{merge}{$x[2..k],y[1..l]\ \circ x[1]$}}
							\Else \State 
								\Return{\Call{merge}{$x[1..k],y[2..l]\ \circ y[1]$}}
							\EndIf
						\EndFunction
					\end{algorithmic}
		\end{enumerate}
		\item[\textbf{5.}]
		\begin{enumerate}
			\item[a)]\quad \\
			Man nutzt einen Stack, um den Queue-Eingang (in) und einen um den Queue-Ausgang (out) zu 
			simulieren.	Soll ein Element(e) in die Queue eingefügt werden, wird einfach einmal push auf 
			dem Eingang-Stack ausgeführt. Soll nun ein Element aus der Schlange entfernt werden, wird der 
			Eingang-Stack komplett auf den Ausgang-Stapel umgestapelt (sie liegen hier also in reverser 
			Reihenfolge vor), daraufhin wird das oberste Element gepullt. Als Abschluss wird der Ausgang-
			Stapel zurück auf den Eingang-Stapel umgestapelt. Auf diese Weise ist das First-in-First-Out-
			Prinzip erfüllt. Die worst-case-Laufzeit beträgt für Dequeue() $\mathcal{O}(n)$, die von
			Enqueue() beträgt $\mathcal{O}$(1).
			\begin{algorithmic} \\
					\Function{Enqueue}{e}
						\State {in.push(e)}
					\EndFunction
					\Function{Dequeue}{}
						\While{!in.isEmpty()}
							\State{out.push(in.pop)}
						\EndWhile
						\State{out.pull()}
						\While{!out.isEmpty()}
							\State{in.push(out.pop)}
						\EndWhile			
					\EndFunction
			\end{algorithmic}	
			\item[b)]\quad \\
				Die worst-case-Laufzeit der Folge von $n$ Operationen ist $n \cdot k$, wobei k den Betrag 
				der Menge der Elemente auf den Stacks darstellt. Die worst-case-Laufzeit ist ein ewiges 
				hintereinanderausführen von Dequeue() (so lange k groß genug ist). Damit liegt $T_n$ in 
				$\mathcal{O}(n)$, die amortisierte Laufzeit berechnet sich dann wie folgt: $\frac{n\cdot 
				k}{n}=k$. $k$ ist zwar keine Konstante (da sie durch Dequeue verringert wird), aber
				selbst wenn man $k$ als eine solche auffasst liegt die amortisierte Laufzeit in 
				$\mathcal{O}(1)$.
		\end{enumerate}
	\end{enumerate}
\end{document}
