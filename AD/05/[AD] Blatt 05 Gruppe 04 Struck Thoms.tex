% Commands

\newcommand{\authorinfo}{Arne Struck, Lars Thoms}
\newcommand{\titleinfo}{AD [HA] zum 18. 12. 2013}
\newcommand{\qed}{\ \square}
\newcommand{\limn}{\lim\limits_{n\to\infty}}
\newcommand{\todo}{\textcolor{red}{\textbf{TODO}}}
\newcommand{\Forall}{\textbf{for each}}

% ------------------------------------------------------

% Packages & Stuff

\documentclass[a4paper,11pt,fleqn]{scrartcl}
\usepackage[german,ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[top=1.3in, bottom=1.2in, left=0.9in, right=0.9in]{geometry}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{pgfplots}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage[parfill]{parskip}
\usetikzlibrary{automata,calc,patterns,shapes}


% ------------------------------------------------------

% Title & Pages

\title{\titleinfo}
\author{\authorinfo}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\authorinfo}
\fancyhead[R]{\titleinfo}
\fancyfoot[C]{\thepage}

\begin{document}
	\maketitle
	\begin{enumerate}
		\item[\textbf{1.:}] \quad \\
			\begin{verbatim}
				BellmanFord_modified(G,s):
				    InitializeSingleSource(G,s)
				    for i = 1, ..., |V| - 1
				        nochanges = false
				        for all edges(u, v) in E
				            distTmp = v.dist
				            Relax(u,v)
				            if v.dist < distTmp
				                nochanges = true
				        if nochanges = true
				            return true
			\end{verbatim}
		
			Die Anpassung durch nochanges bewirkt eine Terminierung einen Durchlauf nachdem alle kürzesten
			Kantenpfade gefunden sind. Dies geschieht, da nach m Durchläufen alle kürzesten Kantenpfade entdeckt
			sind. Die Schleife wird noch einmal durchlaufen und hier wird festgestellt, dass insgesamt keine
			Änderungen an einem der Pfadgewichte vorgenommen wurde. Also wird der Algorithmus darauf Terminieren.
			Weitere Terminierungen sollten nicht sinnvoll sein, da sie durch den spezifizierten Input (kein
			negativen Zyklen) obsolet geworden sind. Der endgültige return kann auch weggelassen werden, da ein 	
			anderer return auf jeden Fall erreicht wird.
		\item[\textbf{2.:}] \quad \\
			\begin{verbatim}
			DAG-Shortest-Path(G,s):
			    sort G.V topologically
			    InitializeSingleSource(G,s)
			    for each u in G.V % now in topological order
			        for each v in Adj(u)
			            Relax(u,v)
			\end{verbatim}				
		% Bin mir bei der Begründung nicht sicher
		%	Die innere Schleife wird \(|E|\) mal durchlaufen, da jede Kante adressiert wird. \\
		%	Die äußere Schleife wird \(|V|\) mal durchlaufen (jeder Knoten ein mal). \\
		%	Durch die vorherige topologische Sortierung ist garantiert, dass der Algorithmus nicht mehrmals
		%	durchlaufen werden muss (da die Knoten jetzt in einer linearen Richtung vorliegen). \\
		%	Damit ist gezeigt, dass die Laufzeit \(\mathcal{O}(|E|+|V|)\) beträgt.
			
		\item[\textbf{3.:}] \quad \\
			Das Problem mit dem Dijkstra-Algorithmus mit negativem Kantengewicht ist, dass sie eventuell nicht
			berücksichtigt werden, da der Algorithmus nicht ''in die Zukunft sehen'' kann. \\
			Da wenn einer der Nachfolgeknoten von S auf dem kürzesten Pfad liegt, muss nur noch gezeigt werden, 
			dass Dijkstra den Knoten korrekt findet. \\
			Angefangen wird immer mit der kleinsten Kantengewichtung zu einem der Nachfolgeknoten von S (im 
			folgenden A). Sollte kein Pfad von A zu einem der anderen Nachfolger von B existieren, wird auch hier
			die negative Kante genommen. Sollte nun ein Pfad von A zu einem der anderen Nachfolger existieren, 
			wird Dijkstra korrekt vergleichen, welcher der beiden Pfade kürzer ist. \\
			Damit ist gezeigt, dass der Algorithmus funktioniert.
		\item[\textbf{4.:}]
		\begin{enumerate}
			\item[a)] \quad \\
				Genutzt wird die DFS (worst-case-Laufzeit \(\mathcal{O}(|V|)\)). Mit dieser wird der am weitest 
				entfernte Knoten vom Root gefunden und der Pfad zwischengespeichert. Dies wird wiederholt mit der 
				Bedingung, dass die beiden Endknoten nicht gleich sein dürfen. \\
				Damit ist der Längste Pfad zwischen 2 Knoten in einem Baum durch aneinanderhängen des einen 
				Zwischenergebnis und dem Reversen des anderen bekannt. Da die zusätzlichen Operationen 
				als Konstanten sind, bleibt die Laufzeit \(\mathcal{O}(|V|)\). \\
			\item[b)] \quad \\
				\begin{verbatim}
				newRelax(u,v)
				    if(v.dist < d(u) + w(u,v))
				        v.dist = u.dist + w(u,v)
				        v.pi
				
				newInit(G,s)
				    for all v in V
				        v.dist = 0
				        v.pi = null
				    s.dist = 0
				    
				newBellmanFord(G,s)
				    newInit(G,s)
				    for i = 1,...,|V| - 1
				        for all edges (u,v) of E
				            newRelax(u,v)
				    for all edges (u,v) of E
				        if v.dist < u.dist + w(u,v)
				            return false
				    return true
				\end{verbatim}
				Durch die Neudefinierung von Bellman-Ford, welcher den längsten Pfad in einem Graph und somit 
				den Durchmesser findet. Dies funktioniert durch das Umkehren des Vergleichs in Relax und der 
				Anpassung der Initialisierung an den neuen Vergleich erreicht. \\
				Der Input (ein ungerichteter Graph) wird aufgrund der Darstellung der Kanten in den Algorithmen
				in einen gerichteten umgewandelt (symmetrische Hin-und Rückkanten werden eingefügt). \\
				Dies führt dazu, dass die Laufzeit vom Bellman-Ford-Algorithmus genommen wird, wobei die 
				Kantenanzahl verdoppelt wird.
		\end{enumerate}
		\item[\textbf{5.:}]
		\begin{enumerate}
			\item[a)] \quad \\
			    Die $n \times n$-Matrix enthält die Wechselkurse der Währungen zueinander. Dies kann man mehr oder weniger direkt in eine Adjazenzmatrix umwandeln und es als vollständigen, gerichteten Graphen darstellen.
			    
			    Dabei entstehen natürlich auch negativ-gewichtete Kanten, wenn eine Währung einen niedrigeren Wert gegenüber einer anderen hat.
			    
			    Der Algorithmus zur Erkennung von Währungsarbitrage ist im Grunde ein BellmanFord-Algorithmus. Er beginnt mit irgendeinem Knoten (Währung) und terminiert mit einem false, wenn er negative Zyklen findet. Dabei muss die Reflexivität der Währungen ignoriert werden.
			\item[b)] \quad \\
				Ja, da der Algorithmus mit einem false terminiert, wenn er einen negativen Zyklus findet. Dadurch kann man ableiten, dass es einen Pfad gibt, der unendlich viel Geld beschert.
				
                Angenommen man würde Euros in Dollars, dann in Yen und wieder in Euros umtauschen und die Wechselkurse Euro-Yen > Euro-Dollar-Yen wären, dann entstünde ein negativer Zyklus.
		\end{enumerate}
		\item[\textbf{6.:}] \quad \\
			\todo
	\end{enumerate}
\end{document}
