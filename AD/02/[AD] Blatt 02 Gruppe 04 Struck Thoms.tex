% Commands

\newcommand{\authorinfo}{Arne Struck, Lars Thoms}
\newcommand{\titleinfo}{AD [HA] zum 6. 11. 2013}
\newcommand{\qed}{\ \square}

% ------------------------------------------------------

% Packages & Stuff

\documentclass[a4paper,11pt,fleqn]{scrartcl}
\usepackage[german,ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[top=1.3in, bottom=1.2in, left=0.9in, right=0.9in]{geometry}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{pgfplots}
\usepackage{multicol}
\usepackage[parfill]{parskip}
\usetikzlibrary{calc}
\usetikzlibrary{patterns}


% ------------------------------------------------------

% Title & Pages

\title{\titleinfo}
\author{\authorinfo}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\authorinfo}
\fancyhead[R]{\titleinfo}
\fancyfoot[C]{\thepage}

\begin{document}
	\maketitle
	\begin{enumerate}
		\item[\textbf{1.}]
		\begin{enumerate}
			\item[a)]\quad \\
				Es liegen \(k^l\) Blätter maximal in der l. Ebene. Von jedem Knoten gehen k Knoten ab, das führt zum 
				folgenden: 0. Ebene (root): \(1 = k^0\), 1. Ebene: \(k = k^1\), 2. Ebene: \(k\cdot k = k^2\),\\
				3. Ebene: \(k\cdot k \cdot k = k^3\) ... l.Ebene: \(k^l\)
			\item[b)]\quad \\
				Der volle Baum hat \(\sum\limits_{i=0}^l k^i = \frac{k^{i+1}-1}{k-1}=\frac{k^i+k^i\cdot(k-1)}{k-1}=
				\frac{k^i-1}{k-1}+k^i\) Knoten, die Summe der Knoten aller Ebenen (eine volle Ebene bemisst sich, wie in a)
				dargestellt auf \(k^l\)).
			\item[c)]\quad \\
				Der vollständige Baum hat \(\sum\limits_{i=0}^{l-1}k^i +c = \frac{k^i-1}{k-1}+k^i-k^l+c\ |c\in\mathbb{N}:1\leq c\leq k^l\)				
				Blätter. Der vollständige Baum ist bis zu seiner vorletzten Ebene maximal gefüllt, deswegen die 
				Summe bis $l-1$, c repräsentiert die Anzahl der Blätter in der letzten Ebene, welche zwischen 
				einem (sonst wäre der Baum voll und hätte l-1 Ebenen) und $k^l$ (ein voller Baum ist 
				vollständig) Blättern.
			\item[d)]\quad \\
				Der Baum hat n-1 Kanten, da jeder Knoten (bis auf den Wurzelknoten) eine Kante besitzt durch 
				die er mit seinem Elternknoten verbunden ist.
		\end{enumerate}
		
		\item[\textbf{2.}]
		\begin{enumerate}
			\item[a)]\quad \\
				Die Laufzeit kann wie folgt (für OrderX) hergeleitet werden, die Reihenfolge der prints ist nicht relevant. 
				\(
				\begin{array}{lll}
					print(v) &\quad & \Theta(1) \\
					OrderX(l) &\quad & \mathcal{O}(\frac{k-1}{2}) \\
					OrderX(r) &\quad & \mathcal{O}(\frac{k-1}{2})
				\end{array}
				\) \\
				Das master-Theorem ist nun anwendbar, \\ \\
				\(T(k)=2T(\big\lceil\frac{ k-1}{2}\big\rceil)+\mathcal{O}(k^0)\) \\
				Da \(\log_2 2 = 1\) gilt, folgt \(\mathcal{O}(k^1)\) 
				
			\item[b)]\quad \\
				Die  Laufzeiten sind bei gleicher Knotenzahl identische (wie in a) zu sehen, alle Algorithmen haben die
				gleiche Anzahl an Aufrufen, da nirgends abgebrochen wird, außer wenn keine Kindknoten verfügbar sind).
				
			\newpage
			\item[c)]\quad \\
				\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
                	    			level 1/.style={sibling distance=50mm},
			        	            level 2/.style={sibling distance=25mm},
            				        level 3/.style={sibling distance=12.5mm},
                				    level 4/.style={sibling distance=6.25mm}]
                				    \node{N}
                				    	child{node{A}
	                							child{node{O}
	                								child{node{E}
	                									child{node{I}}
	                								}
	                								child{node{F}}
	                							}
	                							child{node{M}
	                								child{node{R}}
	                								child{node{L}}
	                							}
	                					}
	                					child{node{U}
	                						child{node{S}
	                							child{node{G}}
	                							child{node{A}}
	                						}
	                						child{node{R}
	                							child{node{T}}
	                							child{node{H}}
	                						}
	                					};
					
				\end{tikzpicture} \\ \\
				Order1: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline N&A&O&E&I&F&M&R&L&U&S&G&A&R&T&H \\ \hline
						\end{tabular} \\
				Order2: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline I&E&O&F&A&R&M&L&N&G&S&A&U&T&R&H \\ \hline
						\end{tabular}  \\
				Order3: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline I&E&F&O&R&L&M&A&G&A&S&T&H&R&U&N \\ \hline
						\end{tabular}  \\
			\item[d)]\quad \\
				Der LOVELYTREE nach Order 2: \\ \\
				\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
                	    			level 1/.style={sibling distance=50mm},
			        	            level 2/.style={sibling distance=25mm},
            				        level 3/.style={sibling distance=12.5mm},
                				    level 4/.style={sibling distance=6.25mm}]
                				    \node{T}
                				    	child{node{E}
                				    		child{node{O}
                				    			child{node{L}}
                				    			child{node{V}}
                				    		}
                				    		child{node{Y}
												child{node{L}}
                				    		}
                				    	}
                				    	child{node{E}
											child{node{R}}
											child{node{E}}                				    	
                				    	}
                				    ;					
				\end{tikzpicture} \\ \\
				Nach Level-Order: Order3: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline T&E&E&O&Y&R&E&L&V&L\\ \hline
						\end{tabular}  \\ \\
				\newpage
			\item[e)]\quad \\
				Ternärer Baum mit vorgegebener Befehlsreihenfolge: \\ \\
				\begin{tikzpicture}[every node/.style={draw,circle,inner sep=1.2pt},
                	    			level 1/.style={sibling distance=40mm},
			        	            level 2/.style={sibling distance=12.5mm},
            				        level 3/.style={sibling distance=10mm}]
                				    \node{N}
                				    	child{node{A}
                				    		child{node{M}
												child{node{T}}                				    			
												child{node{H}}
												child{node{I}}
                				    		}  
                				    		child{node{S}}
                				    		child{node{R}}
                				    	}
                				    	child{node{U}
        	        				    	child{node{E}}
    	            				    	child{node{F}}
	                				    	child{node{R}}
                				    	}
                				    	child{node{o}
        	        				    	child{node{L}}
    	            				    	child{node{G}}
	                				    	child{node{A}}
                				    	}
                				    ;					
				\end{tikzpicture} \\ \\
				Ausgabe: Order3: \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
							\hline A&L&G&O&R&I&T&H&M&S&A&R&E&F&U&N \\ \hline
						\end{tabular}  \\
		\end{enumerate}
		\item[\textbf{3.}]
		\begin{enumerate}
			\item[a)]\quad \\
				\(
				\begin{array}{rcl}
				\Big(x\cdot \frac{\ln(n)}{\ln(x)}\Big)' &=& 
					\frac{\ln(n)}{\ln(x)}+\Big(\frac{\ln(n)}{\ln(x)}\Big)' \\
					&=& \frac{\ln(n)}{\ln(x)} - \frac{\ln(n)\ln(x)'}{(\ln(x))^2} \\
					&=& \frac{\ln(n)}{\ln(x)} - \frac{\ln(n)\ln(x)'}{(\ln(x))^2} \\
					&=& \frac{\ln(n)}{\ln(x)} - \frac{\ln(n)}{x(\ln(x))^2} \\
					&=& \frac{\ln(n)\ln(x)}{\ln(x)^2} - \frac{\ln(n)}{x(\ln(x))^2} \\
					&=& \frac{\ln(n)(\ln(x)-1)}{\ln(x)^2} \\
				\end{array} 
				\)
				Man sieht, dass einer der Faktoren im Zähler 0 sein muss, damit \(\frac{\ln(n)(\ln(x)-1)}{\ln(x)^2} = 0\)
				gilt. Da n beliebig, aber fest ist, ist die Frage, für welches x dies gilt. Wenn $x = e$ gilt, dann 
				folgt \(\frac{\ln(n)(\ln(e)-1)}{\ln(e)^2} = \frac{0}{1}\)
			\item[b)]\quad \\
				Wir wissen aus b), dass das ideale $x = k = e$ gilt, da $k\in\mathbb{N}$ gilt und $e$ näher an 3, als an 2 ist,
				ist $k=3$ die optimale Belegung für jedes $n$ \\ \\
				\(
				\begin{array}{rcl}
					\lceil 3 \cdot\log_3(10^1)\rceil &=& 7 \\
					\lceil 3 \cdot\log_3(10^2)\rceil &=& 13 \\
					\lceil 3 \cdot\log_3(10^3)\rceil &=& 19 \\
					\lceil 3 \cdot\log_3(10^4)\rceil &=& 26 \\
					\lceil 3 \cdot\log_3(10^5)\rceil &=& 32 \\
					\lceil 3 \cdot\log_3(10^6)\rceil &=& 38 \\
					\lceil 3 \cdot\log_3(10^7)\rceil &=& 45 \\
					\lceil 3 \cdot\log_3(10^8)\rceil &=& 51 \\
					\lceil 3 \cdot\log_3(10^9)\rceil &=& 57 \\
				\end{array}
				\) \quad \quad
				\(
				\begin{array}{rcl}
					\lceil 2 \cdot\log_2(10^1)\rceil &=& 7 \\
					\lceil 2 \cdot\log_2(10^2)\rceil &=& 14 \\
					\lceil 2 \cdot\log_2(10^3)\rceil &=& 20 \\
					\lceil 2 \cdot\log_2(10^4)\rceil &=& 27 \\
					\lceil 2 \cdot\log_2(10^5)\rceil &=& 34 \\
					\lceil 2 \cdot\log_2(10^6)\rceil &=& 40 \\
					\lceil 2 \cdot\log_2(10^7)\rceil &=& 47 \\
					\lceil 2 \cdot\log_2(10^8)\rceil &=& 54 \\
					\lceil 2 \cdot\log_2(10^9)\rceil &=& 60 \\
				\end{array}
				\)
			\item[c)]\quad \\
				k = 2 wird verwendet, weil die momentane Rechnerstrukturen, Binärstrukturen einfacher verarbeiten können.
				
			\item[d)]\quad \\
				\textcolor{red}{TODO}
			\item[e)]\quad \\
				\textcolor{red}{TODO}
			\item[f)]\quad \\
				\textcolor{red}{TODO}
		\end{enumerate}
		\item[\textbf{4.}]
		\begin{enumerate}
			\item[a)]\quad \\
				\textcolor{red}{TODO}
			\item[b)]\quad \\
				\textcolor{red}{TODO}
			\item[c)]\quad \\
				\textcolor{red}{TODO}
		\end{enumerate}
		\item[\textbf{5.}]
		\begin{enumerate}
			\item[a)]\quad \\
				\textcolor{red}{TODO}
			\item[b)]\quad \\
				\textcolor{red}{TODO}
		\end{enumerate}
	\end{enumerate}
\end{document}
